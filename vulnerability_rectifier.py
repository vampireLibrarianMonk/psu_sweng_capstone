import argparse
import os

from llama_cpp import Llama

from utilities_llm import (setup_logger,
                           get_optimal_gpu_layers,
                           get_block_count_keys,
                           validate_bandit_allowance,
                           parse_python_script, run_mitigation_loop, process_streamed_output, extract_code_block,
                           save_code_to_file
                           )

mitigated_folder = "mitigated_files"

os.makedirs(mitigated_folder, exist_ok=True)

# Specify the path to your GGUF model file
model_path = "models/llama-3.2-3b-instruct-q8_0.gguf"

# Set up argument parser
parser = argparse.ArgumentParser(description='Process a Python file for vulnerability assessment.')
parser.add_argument('file_path', help='Path to the Python file to be analyzed.')
parser.add_argument('bandit_allowance', help='Allowed iteration of bandit mitigation runs (inclusive).')

# Parse command-line arguments
args = parser.parse_args()

# Set up argument parser
parser = argparse.ArgumentParser(description='Process a Python file for vulnerability assessment.')
parser.add_argument('file_path', help='Path to the Python file to be analyzed.')
parser.add_argument('bandit_allowance', type=validate_bandit_allowance, help='Allowed number of Bandit '
                                                                             'mitigation runs (must be a positive '
                                                                             'integer).')

# Parse command-line arguments
args = parser.parse_args()

input_file_path = args.file_path
bandit_allowance = args.bandit_allowance

# Get and separate file name into its base name and extension
base_name = os.path.basename(input_file_path)
name, ext = os.path.splitext(base_name)

# Initialize the logger
logger = setup_logger(f"vulnerability_rectifier_{name}")

# Read the specified file and use ast to parse it into a map for quicker analysis and mitigation
parsed_script = parse_python_script(input_file_path)

# Get the total layers from the input model
total_layers = get_block_count_keys(model_path, logger)

# Determine the optimal number of GPU layers to offload
n_gpu_layers = get_optimal_gpu_layers(model_path, total_layers)

# Initialize the Llama model with appropriate settings
llm = Llama(
    model_path=model_path,
    seed=42,  # Fixed seed for reproducibility
    n_ctx=4096,  # Set the desired context size here
    use_mmap=True,  # Memory mapping for efficiency
    use_mlock=True,  # Prevent swapping to disk for consistent performance
    n_gpu_layers=n_gpu_layers
)

new_parsed_script = {
        'global_variables': '',
        'methods': {},
        'main_script': ''
    }

for section, original_code in parsed_script.items():
    logger.info(f"Processing section: {section}...")

    if section == 'methods' and parsed_script['methods']:
        for method, method_code in parsed_script['methods'].items():
            # Mitigate Code
            new_code_block = run_mitigation_loop(
                bandit_allowance,
                base_name,
                llm,
                logger,
                mitigated_folder,
                method_code,
                method)

            # Update code via input section
            new_parsed_script['methods'][method] = new_code_block

    elif parsed_script[section]:
        new_code_block = run_mitigation_loop(
            bandit_allowance,
            base_name,
            llm,
            logger,
            mitigated_folder,
            original_code,
            section)

        # Update code via input section
        new_parsed_script[section] = new_code_block

    else:
        logger.info(f"No code found in section {section}.")


# Check if there is any code parsed
is_empty = (new_parsed_script['global_variables'] == ''
            and new_parsed_script['main_script'] == ''
            and not new_parsed_script['methods'])

# If there is actually new code to integrate
if not is_empty:
    # Final code script naming conventions and file path
    mitigated_file_name = f"{name}_mitigated_final{ext}"
    new_mitigated_file_path = os.path.join(mitigated_folder, mitigated_file_name)

    # Open the file in write mode and write the sections
    with open(new_mitigated_file_path, 'w') as file:
        # Write variables section
        if new_parsed_script['global_variables']:
            file.write(new_parsed_script['global_variables'] + '\n\n')

        # Write methods section in alphabetical order
        for method_name in sorted(new_parsed_script['methods']):
            file.write(new_parsed_script['methods'][method_name] + '\n\n')

        # Write main_script section
        if new_parsed_script['main_script']:
            file.write(new_parsed_script['main_script'] + '\n')

    # Read the contents of the generated file
    with open(new_mitigated_file_path, 'r') as file:
        code_content = file.read()

