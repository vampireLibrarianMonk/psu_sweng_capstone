{
    "os.system":"Replace the use of os.system with native Python libraries to directly perform the intended task. This avoids reliance on shell commands entirely, mitigating injection vulnerabilities. Instead of executing commands via shell, utilize Python's built-in modules for file handling, OS interactions, and other common tasks.",
    "subprocess": "Analyze the file to identify an alternative pathway that accomplishes the input script's intended function using only native Python libraries, such as os, shutil, pathlib, or socket. Avoid reliance on subprocess or external tools by leveraging Python's built-in capabilities for file handling, process management, and network operations.",
    "pickle": "Replace the pickle module with the json module for serialization and deserialization. JSON handles basic data types securely and doesn't execute arbitrary code during deserialization, reducing the risk of code injection attacks.",
    "tempfile": "Avoid hardcoding directory paths for temporary files. Instead, utilize the module's default behavior, which automatically selects a secure and appropriate directory for temporary files based on your system's environment.",
    "flask": "Always add `instance_relative_config=True` in `Flask` constructor to allow load configurations from an instance folder for environment-specific or sensitive settings.",
    "hashlib": "When using the hashlib.scrypt method, always provide a strong, randomly generated salt (e.g., os.urandom(16)) for each password. Carefully choose parameters (n, r, and p) based on your security and performance requirements. Store both the salt and hash securely together in a standardized format (e.g., salt$hashed_password), converting the salt to a hex string for storage. During verification, ensure the stored salt is converted back to its original bytes format (e.g., using bytes.fromhex()) before passing it to hashlib.scrypt for hash computation."
}
